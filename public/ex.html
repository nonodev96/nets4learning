<!DOCTYPE html>
<html>
<head>
    <title>TensorFlow.js Example</title>

    <!-- Import TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.0.0/dist/tf.min.js"></script>
    <!-- Import tfjs-vis -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-vis@1.0.2/dist/tfjs-vis.umd.min.js"></script>

    <!-- Import the main script file -->
    <script>
      let tensorData;
      let trainedModel;
      const loadedData = [
        { "age": 90.4, "price": 19.4 },
        { "age": 74.9, "price": 23.7 },
        { "age": 34.5, "price": 26.6 },
        { "age": 82.5, "price": 22.8 },
        { "age": 77.9, "price": 25.8 },
      ]

      async function loadData() {

        tensorData = convertToTensor(loadedData);
        await plotRawData();
        document.getElementById("btnTrain").disabled = false;
      }

      async function plotRawData() {
        const values = loadedData.map(d => ({
          x: d.age,
          y: d.price,
        }));

        await tfvis.render.scatterplot(
          { name: 'Age v Price' },
          { values },
          {
            xLabel: 'Age of property',
            yLabel: 'Price',
            height: 300
          }
        );
      }

      async function runTrainModel() {
        const { inputs, labels } = tensorData;
        trainedModel = getModel();

        // Train the model
        await trainModel(inputs, labels);
        await tfvis.show.modelSummary({ name: 'Model Summary' }, trainedModel);
        document.getElementById("btnPredict").disabled = false;
        document.getElementById("txtInput").disabled = false;
      }

      function runPredict() {
        let predictionInput = document.getElementById("txtInput").value.split(',').map(val => parseInt(val));
        predict(loadedData, tensorData, predictionInput);
      }

      function getModel() {
        // add a sequential model
        const model = tf.sequential();
        // Add a hidden layer
        model.add(tf.layers.dense({ inputShape: [1], units: 1, useBias: true }));
        // Add the output layer
        model.add(tf.layers.dense({ units: 1, useBias: true }));
        return model;
      }

      function convertToTensor(data) {

        return tf.tidy(() => {
          tf.util.shuffle(data);

          const inputs = data.map(d => d.age)
          const labels = data.map(d => d.price);

          const inputTensor = tf.tensor2d(inputs, [inputs.length, 1]);
          const labelTensor = tf.tensor2d(labels, [labels.length, 1]);

          const inputMax = inputTensor.max();
          const inputMinVal = inputTensor.min();
          const labelMax = labelTensor.max();
          const labelMinVal = labelTensor.min();

          const normInputs = inputTensor.sub(inputMinVal).div(inputMax.sub(inputMinVal));
          const normLabels = labelTensor.sub(labelMinVal).div(labelMax.sub(labelMinVal));

          return {
            inputs: normInputs,
            labels: normLabels,
            // Return the min/max bounds so we can use them later.
            inputMax,
            inputMinVal,
            labelMax,
            labelMinVal,
          }
        });
      }

      async function trainModel(inputs, labels) {
        // Prepare the model for training.
        trainedModel.compile({
          optimizer: tf.train.adam(),
          loss     : tf.losses.meanSquaredError,
          metrics  : ['mse'],
        });

        const batchSize = 32;
        const epochs = 50;

        return await trainedModel.fit(inputs, labels, {
          batchSize,
          epochs,
          shuffle  : true,
          callbacks: tfvis.show.fitCallbacks(
            { name: 'Training Performance' },
            ['loss', 'mse'],
            { height: 200, callbacks: ['onEpochEnd'] }
          )
        });
      }

      function predict(inputData, normalizationData, predictionInput) {
        const { inputMax, inputMinVal, labelMinVal, labelMax } = normalizationData;

        const [vals, predictions] = tf.tidy(() => {
          let inputTenser = tf.tensor2d(predictionInput, [predictionInput.length, 1]);
          const vals = inputTenser.sub(inputMinVal).div(inputMax.sub(inputMinVal));
          const predictions = trainedModel.predict(vals.reshape([predictionInput.length, 1]));

          const unNormXs = vals.mul(inputMax.sub(inputMinVal)).add(inputMinVal);
          const unNormPredictions = predictions.mul(labelMax.sub(labelMinVal)).add(labelMinVal);

          // Un-normalize the data
          return [unNormXs.dataSync(), unNormPredictions.dataSync()];
        });


        const predictedPoints = Array.from(vals).map((val, i) => {
          return {
            x: val,
            y: predictions[i]
          }
        });

        const originalPoints = inputData.map(d => ({
          x: d.age, y: d.price,
        }));


        tfvis.render.scatterplot(
          { name: 'Model Predictions vs Original Data' },
          { values: [originalPoints, predictedPoints], series: ['original', 'predicted'] },
          {
            xLabel: 'age',
            yLabel: 'price',
            height: 300
          }
        );
      }
    </script>
</head>
<button id="btnLoad" onclick="loadData()">Load Data</button>
<button id="btnTrain" onclick="runTrainModel()" disabled=true>Train Model</button>
<button id="btnPredict" onclick="runPredict()" disabled=true>Predict</button>
<br/><br/>
<span>age of property:</span><br/>
<textarea id="txtInput" disabled=true>40,70,90,100,60</textarea>
<body>

</body>
</html>